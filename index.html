<script>
// ==========================================
// V3.30 å„ªåŒ–ç‰ˆï¼šç²¾æº–å°æ¥ Excel å€é–“ Key
// ==========================================

// 0. ç²å–æ¬Šé‡ä¿‚æ•¸ (ç¶­æŒåŸæ¨£)
function getWeightCoefficient(category, value) {
    if (!window.WEIGHT_COEFFICIENTS || !window.WEIGHT_COEFFICIENTS[category]) {
        return 1.0;
    }
    const coefData = window.WEIGHT_COEFFICIENTS[category][value];
    if (!coefData) {
        // console.warn(`æ‰¾ä¸åˆ°æ¬Šé‡ä¿‚æ•¸: ${category} - ${value}`); // é—œé–‰è­¦å‘Šä¿æŒä»‹é¢ä¹¾æ·¨
        return 1.0;
    }
    return coefData.coefficient;
}

// æŸ¥è©¢åˆ¸å•† (ç¶­æŒåŸæ¨£)
function getBrokerName(cbName) {
    if (!window.BROKER_MAPPING) return null;
    return window.BROKER_MAPPING[cbName] || null;
}

// ==========================================
// 1. åˆ†é¡å‡½æ•¸ä¿®æ­£ (é—œéµä¿®æ”¹ï¼)
// è®“å›å‚³çš„å­—ä¸²è·Ÿ Excel Sheet 05 çš„ Key å®Œå…¨ä¸€è‡´
// ==========================================

function classifyCapital(value) {
    const v = parseFloat(value);
    if (v < 3) return "1_è‚¡æœ¬å¤§å°_å°æ–¼3å„„";
    if (v < 6) return "2_è‚¡æœ¬å¤§å°_3~6å„„";
    if (v < 10) return "3_è‚¡æœ¬å¤§å°_6~10å„„";
    if (v < 15) return "4_è‚¡æœ¬å¤§å°_10~15å„„";
    if (v < 20) return "5_è‚¡æœ¬å¤§å°_15~20å„„";
    return "6_è‚¡æœ¬å¤§å°_å¤§æ–¼20å„„";
}

function classifySize(value) {
    const v = parseFloat(value);
    if (v < 2) return "1_ç™¼è¡Œè¦æ¨¡_å°æ–¼2å„„";
    if (v < 5) return "2_ç™¼è¡Œè¦æ¨¡_2~5å„„";
    if (v < 10) return "3_ç™¼è¡Œè¦æ¨¡_5~10å„„";
    if (v < 15) return "4_ç™¼è¡Œè¦æ¨¡_10~15å„„";
    if (v < 20) return "5_ç™¼è¡Œè¦æ¨¡_15~20å„„";
    return "6_ç™¼è¡Œè¦æ¨¡_å¤§æ–¼20å„„";
}

function classifyConversionPrice(value) {
    const v = parseFloat(value);
    if (v < 20) return "1_è½‰æ›åƒ¹æ ¼_å°æ–¼20å…ƒ";
    if (v < 50) return "2_è½‰æ›åƒ¹æ ¼_ä»‹æ–¼20~50å…ƒ";
    if (v < 100) return "3_è½‰æ›åƒ¹æ ¼_ä»‹æ–¼50~100å…ƒ";
    if (v < 150) return "4_è½‰æ›åƒ¹æ ¼_ä»‹æ–¼100~150å…ƒ";
    if (v < 200) return "5_è½‰æ›åƒ¹æ ¼_ä»‹æ–¼150~200å…ƒ";
    return "6_è½‰æ›åƒ¹æ ¼_å¤§æ–¼200å…ƒ";
}

function classifyYears(value) {
    return value.toString();
}

// å…¨åŸŸè®Šæ•¸
let statistics = null;
let cbDatabase = null;
let cbNameMap = {};
let auctionRawData = null;
let globalMarketStats = { low: 0, avg: 0 };

function safeFloat(val) {
    if (val === undefined || val === null || val === '') return 0;
    if (typeof val === 'string') val = val.replace(/,/g, '').replace(/%/g, ''); // å¢å¼·æŠ—éŒ¯
    const num = parseFloat(val);
    return isNaN(num) ? 0 : num;
}

// 2. è³‡æ–™è®€å–èˆ‡ç´¢å¼•å»ºç«‹ (ç¶­æŒ JSON è®€å–é‚è¼¯)
async function loadStatistics() {
    const loadingDiv = document.getElementById('loading');
    const detailDiv = document.getElementById('loading-detail');

    try {
        detailDiv.textContent = "æ­£åœ¨åŒæ­¥è®€å–æ•¸æ“šåº«...";
        const [resMain, resNames] = await Promise.all([
            fetch('cb_data_integrated.json').then(res => res.ok ? res.json() : null).catch(e => null),
            fetch('cb_names_database.json').then(res => res.ok ? res.json() : null).catch(e => null)
        ]);

        if (!resMain) throw new Error("æ‰¾ä¸åˆ°ä¸»çµ±è¨ˆæª” (cb_data_integrated.json)ï¼Œè«‹æª¢æŸ¥æª”æ¡ˆåç¨±æ˜¯å¦æ­£ç¢º");

        statistics = resMain['çµ±è¨ˆæ•¸æ“š']; // é€™è£¡å°æ‡‰åˆ° Sheet 05
        auctionRawData = resMain['ç«¶æ‹åŸå§‹è³‡æ–™'] || []; // é€™è£¡å°æ‡‰åˆ° Sheet 04
        let mainDB = resMain['CBè³‡æ–™åº«'] || {}; // é€™è£¡å°æ‡‰åˆ° Sheet 01

        if (resNames) {
            cbDatabase = { ...mainDB, ...resNames };
        } else {
            cbDatabase = mainDB;
        }

        // å»ºç«‹åç¨±ç´¢å¼•
        if (cbDatabase) {
            Object.values(cbDatabase).forEach(item => {
                if (item['åç¨±']) {
                    cbNameMap[item['åç¨±']] = item;
                }
            });
        }

        calculateGlobalMarketStats();
        initializeUI();
        loadingDiv.style.display = 'none';
        document.querySelector('.container').style.display = 'block';

    } catch (error) {
        console.error(error);
        loadingDiv.innerHTML = `<div style="padding:30px; background:white; color:#d32f2f; border-radius:10px; text-align:center; max-width:80%;"><h3 style="margin-bottom:10px;">âŒ ç³»çµ±å•Ÿå‹•å¤±æ•—</h3><p style="font-size:16px;">${error.message}</p><p style="font-size:14px; color:#666; margin-top:10px;">è«‹ç¢ºèª GitHub ä¸Šçš„æª”åæ˜¯å¦ç‚º <b>cb_data_integrated.json</b></p></div>`;
    }
}

function calculateGlobalMarketStats() {
    if (auctionRawData && auctionRawData.length > 0) {
        let sumLow = 0, sumAvg = 0, count = 0;
        auctionRawData.forEach(d => {
            let l = safeFloat(d['æœ€ä½æº¢åƒ¹'] || d['s1']); // ç›¸å®¹ s1 èˆŠæ¬„ä½
            let a = safeFloat(d['å¹³å‡æº¢åƒ¹'] || d['u1']); // ç›¸å®¹ u1 èˆŠæ¬„ä½
            
            // è‡ªå‹•ä¿®æ­£å–®ä½ (0.05 -> 5)
            if (l < 2 && l > -2) l *= 100;
            if (a < 2 && a > -2) a *= 100;

            if (l > -10 && l < 200) { sumLow += l; sumAvg += a; count++; }
        });
        if (count > 0) {
            globalMarketStats.low = (sumLow / count);
            globalMarketStats.avg = (sumAvg / count);
        }
    }
}

// 3. æ™ºèƒ½å€é–“åŒ¹é… (è¼”åŠ©ç”¨ï¼Œä¸»è¦ä¾é  classify å‡½æ•¸)
function findBestRangeKey(category, value) {
    if (!statistics || !statistics['ç¶­åº¦çµ±è¨ˆ'] || !statistics['ç¶­åº¦çµ±è¨ˆ'][category]) return null;
    
    // å¦‚æœæ˜¯æ•¸å€¼ï¼Œå„ªå…ˆä½¿ç”¨åˆ†é¡å‡½æ•¸ç”¢ç”Ÿçš„ Key
    if (category === 'è‚¡æœ¬') return classifyCapital(value);
    if (category === 'ç™¼è¡Œè¦æ¨¡') return classifySize(value);
    if (category === 'è½‰æ›åƒ¹') return classifyConversionPrice(value);
    
    // å¦‚æœéƒ½æ²’å°æ‡‰åˆ°ï¼Œæ‰è·‘èˆŠçš„æ¨¡ç³Šæ¯”å° (ä¿ç•™åŸæœ¬é‚è¼¯ä½œç‚ºå‚™æ¡ˆ)
    const keys = Object.keys(statistics['ç¶­åº¦çµ±è¨ˆ'][category]);
    for (let key of keys) {
        if (key === value) return key;
    }
    return null;
}

// 4. å…¨èƒ½å‹•æ…‹çµ±è¨ˆé‹ç®— (æ ¸å¿ƒåŠŸèƒ½)
function getDynamicStats(filterFn) {
    if (!auctionRawData || auctionRawData.length === 0) return null;

    const matches = auctionRawData.filter(filterFn);
    if (matches.length === 0) return null;

    let sumLowPrice = 0, sumAvgPrice = 0, sumLowPrem = 0, sumAvgPrem = 0;
    let sumHigh = 0, sumLow = 0;
    let count = 0, marketCount = 0;

    matches.forEach(d => {
        const lowPrice = safeFloat(d['æœ€ä½å¾—æ¨™'] || d['æœ€ä½å¾—æ¨™åƒ¹æ ¼'] || d['r1']);
        let lowPrem = safeFloat(d['æœ€ä½æº¢åƒ¹'] || d['æœ€ä½å¾—æ¨™åƒ¹æ ¼_æº¢åƒ¹ç‡'] || d['s1']);
        const avgPrice = safeFloat(d['å¹³å‡å¾—æ¨™'] || d['å¾—æ¨™åŠ æ¬Šå¹³å‡åƒ¹æ ¼'] || d['t1']);
        let avgPrem = safeFloat(d['å¹³å‡æº¢åƒ¹'] || d['å¾—æ¨™åŠ æ¬Šå¹³å‡åƒ¹æ ¼_æº¢åƒ¹ç‡'] || d['u1']);

        // å–®ä½ä¿®æ­£
        if (Math.abs(lowPrem) < 2) lowPrem *= 100;
        if (Math.abs(avgPrem) < 2) avgPrem *= 100;

        if (lowPrice > 0 || Math.abs(lowPrem) > 0) {
            sumLowPrice += lowPrice;
            sumAvgPrice += avgPrice;
            sumLowPrem += lowPrem;
            sumAvgPrem += avgPrem;
            count++;
        }

        // è®€å–æ›ç‰Œæ•¸æ“š
        const cbName = d['åç¨±'] || d['CBåç¨±'];
        if (cbName && cbNameMap[cbName]) {
            const cbInfo = cbNameMap[cbName];
            const h = safeFloat(cbInfo['æ›ç‰Œæœ€é«˜']);
            const l = safeFloat(cbInfo['æ›ç‰Œæœ€ä½']);
            if (h > 0 && l > 0) {
                sumHigh += h;
                sumLow += l;
                marketCount++;
            }
        }
    });

    if (count === 0) return null;

    return {
        'å¹³å‡æœ€ä½å¾—æ¨™': sumLowPrice / count,
        'å¹³å‡æœ€ä½æº¢åƒ¹': sumLowPrem / count,
        'å¹³å‡å¾—æ¨™åƒ¹': sumAvgPrice / count,
        'å¹³å‡æº¢åƒ¹': sumAvgPrem / count,
        'å¹³å‡æ›ç‰Œæœ€é«˜': marketCount > 0 ? sumHigh / marketCount : 0,
        'å¹³å‡æ›ç‰Œæœ€ä½': marketCount > 0 ? sumLow / marketCount : 0,
        'æ¨£æœ¬æ•¸': count
    };
}

// 5. æ™ºèƒ½æ•¸æ“šç²å–ä»‹é¢ (æ•´åˆ æŸ¥è¡¨ + å‹•æ…‹)
function getStatsSmart(category, val) {
    let stats = { low: 0, avg: 0, usedFallback: false, rawData: null };
    let filterFn = null;

    // A. è™•ç† "åˆ†é¡å€é–“" (è‚¡æœ¬ã€è¦æ¨¡ã€è½‰æ›åƒ¹)
    // å„ªå…ˆä½¿ç”¨ "æŸ¥è¡¨æ³•" (å› ç‚ºé€™äº›å€é–“çš„çµ±è¨ˆåœ¨ Sheet 05 å·²ç¶“ç®—å¥½äº†)
    if (['è‚¡æœ¬', 'ç™¼è¡Œè¦æ¨¡', 'è½‰æ›åƒ¹'].includes(category)) {
        // ä½¿ç”¨ä¿®æ­£å¾Œçš„ classify å‡½æ•¸å–å¾—æ­£ç¢º Key (ä¾‹å¦‚: "6_è‚¡æœ¬å¤§å°_å¤§æ–¼20å„„")
        let key = findBestRangeKey(category, val);
        
        if (key && statistics['ç¶­åº¦çµ±è¨ˆ'] && statistics['ç¶­åº¦çµ±è¨ˆ'][category] && statistics['ç¶­åº¦çµ±è¨ˆ'][category][key]) {
            let data = statistics['ç¶­åº¦çµ±è¨ˆ'][category][key];
            stats.rawData = data;
            stats.low = safeFloat(data['å¹³å‡æœ€ä½æº¢åƒ¹'] || data['æ­·å²æœ€ä½æº¢åƒ¹']);
            stats.avg = safeFloat(data['å¹³å‡æº¢åƒ¹'] || data['æ­·å²å¹³å‡æº¢åƒ¹']);
            return stats;
        }
    }

    // B. è™•ç† "é¡åˆ¥" (ç”¢æ¥­ã€åˆ¸å•†ã€æ“”ä¿ã€å¹´æœŸã€ä¿¡è©•)
    // å„ªå…ˆä½¿ç”¨ "å‹•æ…‹é‹ç®—æ³•" (å› ç‚º Sheet 04 è³‡æ–™æœ€é½Šå…¨)
    if (category === 'ç™¼è¡Œåˆ¸å•†') {
        filterFn = d => {
            const name = d['ç™¼è¡Œåˆ¸å•†'] || d['æ‰¿éŠ·åˆ¸å•†'] || d['ä¸»è¾¦åˆ¸å•†'] || '';
            return name.includes(val) || val.includes(name);
        };
    } else if (category === 'ç”¢æ¥­') {
        filterFn = d => (d['ç”¢æ¥­åˆ†é¡'] || d['ç”¢æ¥­åˆ¥']) === val;
    } else if (category === 'æ“”ä¿') {
        filterFn = d => (d['æ“”ä¿'] || '').includes(val);
    } else if (category === 'å¹´æœŸ') {
        filterFn = d => safeFloat(d['å¹´æœŸ'] || d['ç™¼è¡Œå¹´æœŸ']) == val;
    } else if (category === 'ä¿¡è©•') {
        filterFn = d => (d['ä¿¡è©•'] || d['TCRI'] || '').toString().includes(val.toString());
    }

    if (filterFn) {
        const dyn = getDynamicStats(filterFn);
        if (dyn) {
            stats.rawData = dyn;
            stats.low = dyn['å¹³å‡æœ€ä½æº¢åƒ¹'];
            stats.avg = dyn['å¹³å‡æº¢åƒ¹'];
            return stats;
        }
    }

    // C. æŸ¥è¡¨å‚™æ¡ˆ (é‡å°éå€é–“çš„æŸ¥è¡¨)
    if (stats.low === 0 && statistics['ç¶­åº¦çµ±è¨ˆ'] && statistics['ç¶­åº¦çµ±è¨ˆ'][category]) {
        let data = statistics['ç¶­åº¦çµ±è¨ˆ'][category][val];
        if (data) {
            stats.rawData = data;
            stats.low = safeFloat(data['å¹³å‡æœ€ä½æº¢åƒ¹']);
            stats.avg = safeFloat(data['å¹³å‡æº¢åƒ¹']);
            return stats;
        }
    }

    // D. è‡ªå‹•æ›¿è£œæ©Ÿåˆ¶ (Global Fallback)
    if (stats.low === 0 || stats.avg === 0) {
        stats.low = globalMarketStats.low;
        stats.avg = globalMarketStats.avg;
        stats.usedFallback = true;
        if (!stats.rawData) stats.rawData = {};
    }

    return stats;
}

// 6. å¡ç‰‡ç”Ÿæˆ
function generateStandardCard(data, titleOverride=null) {
    if (!data) return `<div class="stat-row" style="color:#999;">æŸ¥ç„¡è³‡æ–™ (å°‡ä½¿ç”¨å¸‚å ´å‡å€¼é‹ç®—)</div>`;

    const val = (v, suffix='') => (v !== undefined && v !== null && v !== '' && !isNaN(v)) ? `${safeFloat(v).toFixed(2)}${suffix}` : '-';

    let html = `
    <div class="stats-header">ğŸ“Š ${titleOverride || 'æ­·å²çµ±è¨ˆ'}</div>
    `;

    if (data['æ¨£æœ¬æ•¸']) {
        html += `<div class="stat-row" style="color:#555; font-weight:bold; margin-bottom:8px;">æ¨£æœ¬æ•¸: ${data['æ¨£æœ¬æ•¸']} æª”</div>`;
    }

    html += `
    <div style="background:#f1f8e9; padding:8px; border-radius:5px; margin-bottom:8px;">
    <div class="stat-row">
    <span class="stat-label">ğŸ“‰ æœ€ä½å¾—æ¨™:</span>
    <span class="stat-value">${val(data['å¹³å‡æœ€ä½å¾—æ¨™'], 'å…ƒ')} / æº¢ ${val(data['å¹³å‡æœ€ä½æº¢åƒ¹'] || data['æ­·å²æœ€ä½æº¢åƒ¹'], '%')}</span>
    </div>
    <div class="stat-row">
    <span class="stat-label">âš–ï¸ å¹³å‡å¾—æ¨™:</span>
    <span class="stat-value">${val(data['å¹³å‡å¾—æ¨™åƒ¹'], 'å…ƒ')} / æº¢ ${val(data['å¹³å‡æº¢åƒ¹'] || data['æ­·å²å¹³å‡æº¢åƒ¹'], '%')}</span>
    </div>
    </div>
    `;

    const h = safeFloat(data['å¹³å‡æ›ç‰Œæœ€é«˜'] || data['æ›ç‰Œæœ€é«˜']);
    const l = safeFloat(data['å¹³å‡æ›ç‰Œæœ€ä½'] || data['æ›ç‰Œæœ€ä½']);
    
    if (h > 0) {
        const amp = l > 0 ? ((h - l) / l * 100).toFixed(1) : 0;
        html += `
        <div style="border-top:1px dashed #ccc; padding-top:8px;">
        <div class="stat-row">
        <span class="stat-label">ğŸ“ˆ æ›ç‰Œæœ€é«˜:</span> <span class="stat-value">${val(h)}</span>
        </div>
        <div class="stat-row">
        <span class="stat-label">ğŸ“‰ æ›ç‰Œæœ€ä½:</span> <span class="stat-value">${val(l)}</span>
        </div>
        <div class="stat-row">
        <span class="stat-label" style="color:#E91E63;">âš¡ å¹³å‡æŒ¯å¹…:</span> <span class="stat-value" style="color:#E91E63;">${amp > 0 ? amp + '%' : '-'}</span>
        </div>
        </div>
        `;
    }
    return html;
}

// 7. åˆå§‹åŒ–èˆ‡ç¶å®š
function initializeUI() {
    document.getElementById('headerSubtitle').textContent = `Rexå¤§å”çš„168å°è‚¡æŠ•è³‡æ•™å®¤ | æ•´åˆ${Object.keys(cbDatabase).length}æª”CBå®Œæ•´è³‡æ–™åº«`;
    
    // ç¢ºä¿ä¸‹æ‹‰é¸å–®è³‡æ–™è¼‰å…¥
    if (statistics['ç¶­åº¦çµ±è¨ˆ']) {
        if (statistics['ç¶­åº¦çµ±è¨ˆ']['ç”¢æ¥­']) populateSelect('industry', statistics['ç¶­åº¦çµ±è¨ˆ']['ç”¢æ¥­']);
        if (statistics['ç¶­åº¦çµ±è¨ˆ']['ç™¼è¡Œåˆ¸å•†']) populateSelect('broker', statistics['ç¶­åº¦çµ±è¨ˆ']['ç™¼è¡Œåˆ¸å•†']);
    }
    
    showStatsSummary();
    bindInputEvents();
}

function populateSelect(id, dataObj) {
    if (!dataObj) return;
    const select = document.getElementById(id);
    while (select.options.length > 1) { select.remove(1); }
    const items = Object.keys(dataObj).sort((a, b) => (dataObj[b]['æ¨£æœ¬æ•¸'] || 0) - (dataObj[a]['æ¨£æœ¬æ•¸'] || 0));
    items.forEach(item => {
        const option = document.createElement('option');
        option.value = item;
        const avgHigh = safeFloat(dataObj[item]['å¹³å‡æ›ç‰Œæœ€é«˜'] || dataObj[item]['æ›ç‰Œæœ€é«˜']);
        option.textContent = avgHigh > 0 ? `${item} (æœ€é«˜${avgHigh.toFixed(1)}å…ƒ)` : item;
        select.appendChild(option);
    });
}

function showStatsSummary() {
    document.getElementById('statsSummary').innerHTML = `
    <div class="stat-box"><div class="number">${Object.keys(cbDatabase).length}</div><div class="label">CBè³‡æ–™åº«</div></div>
    <div class="stat-box"><div class="number">${statistics['è³‡æ–™æœŸé–“'] ? statistics['è³‡æ–™æœŸé–“']['ç¸½ç­†æ•¸'] : auctionRawData.length}</div><div class="label">ç«¶æ‹æ¡ˆä¾‹</div></div>
    `;
}

function bindInputEvents() {
    const show = (id, html) => {
        const el = document.getElementById(id); el.innerHTML = html||''; el.style.display = html?'block':'none';
    };

    // CB åç¨±åæŸ¥åŠŸèƒ½
    document.getElementById('cbName').addEventListener('input', function() {
        const val = this.value.trim();
        if (!val) { show('cbNameInfo', null); return; }
        let found = null;
        if (cbNameMap[val]) found = cbNameMap[val];
        else found = Object.values(cbDatabase).find(d => d['åç¨±'] && d['åç¨±'].includes(val));

        if (found) {
            let html = `<div class="stats-header">ğŸ“Š æ›ç‰Œåƒ¹æ ¼åƒè€ƒ</div><div class="stat-row">${found['ä»£è™Ÿ'] || ''} / ${found['è‚¡ç¥¨ä»£è™Ÿ'] || ''}</div>`;
            if (found['æ›ç‰Œæœ€é«˜']) {
                const h = safeFloat(found['æ›ç‰Œæœ€é«˜']), l = safeFloat(found['æ›ç‰Œæœ€ä½']);
                const amp = l > 0 ? ((h-l)/l*100).toFixed(2) : 0;
                html += `<div class="stat-row" style="justify-content:space-between;"><span>ğŸ“ˆ æœ€é«˜:${h}</span><span>ğŸ“‰ æœ€ä½:${l}</span><span style="color:#E91E63;">âš¡ ${amp}%</span></div>`;
            }
            show('cbNameInfo', html);
        } else show('cbNameInfo', null);
    });

    const bind = (id, cat, isNum) => {
        document.getElementById(id).addEventListener(isNum ? 'input' : 'change', function() {
            const val = isNum ? parseFloat(this.value) : this.value;
            if (val) {
                // çµ±ä¸€ä½¿ç”¨ Smart ç²å–
                const smartResult = getStatsSmart(cat, val);
                const data = smartResult.rawData;
                
                // å€é–“é¡é¡¯ç¤º Keyï¼Œéå€é–“é¡¯ç¤º Value
                let displayKey = val;
                if(isNum) displayKey = findBestRangeKey(cat, val) || val;
                
                show(id+'Info', generateStandardCard(data, `æ­·å²çµ±è¨ˆ (${displayKey})`));
                
                if (cat === 'è½‰æ›åƒ¹' || cat === 'ä¿¡è©•') updateSmartReminders();
            }
        });
    };

    bind('capital', 'è‚¡æœ¬', true);
    bind('issueSize', 'ç™¼è¡Œè¦æ¨¡', true);
    bind('conversionPrice', 'è½‰æ›åƒ¹', true);
    bind('industry', 'ç”¢æ¥­', false);
    bind('broker', 'ç™¼è¡Œåˆ¸å•†', false);
    bind('years', 'å¹´æœŸ', true);

    document.getElementById('guarantee').addEventListener('change', function() {
        const smartResult = getStatsSmart('æ“”ä¿', this.value);
        show('guaranteeInfo', generateStandardCard(smartResult.rawData, `æ­·å²çµ±è¨ˆ (${this.value})`));
        updateMarketSentimentDisplay();
    });

    bind('rating', 'ä¿¡è©•', false);
    document.getElementById('stockPrice').addEventListener('input', updateSmartReminders);
}

function updateSmartReminders() {
    const stock = parseFloat(document.getElementById('stockPrice').value);
    const conv = parseFloat(document.getElementById('conversionPrice').value);
    const div = document.getElementById('smartReminders');
    if (stock && conv) {
        const theo = (stock/conv)*100;
        let msg = theo > 115 ? 'âš ï¸ ç›®å‰ç†è«–åƒ¹åé«˜ï¼Œéœ€æ³¨æ„æº¢åƒ¹é¢¨éšª' : theo < 90 ? 'ğŸ’¡ ç†è«–åƒ¹ä½æ–¼ä½æª”ï¼Œå¯èƒ½æœ‰å¥—åˆ©ç©ºé–“' : 'âœ¨ ç†è«–åƒ¹ä½æ–¼åˆç†å€é–“';
        document.getElementById('reminderContent').textContent = msg;
        div.style.display = 'block';
    }
}

function updateMarketSentimentDisplay() {
    const guarantee = document.getElementById('guarantee').value;
    const div = document.getElementById('marketSentiment');
    if (!guarantee || !auctionRawData) return;

    const similarCases = auctionRawData.filter(item => (item['æ“”ä¿']||'').includes(guarantee));
    if (similarCases.length === 0) {
        div.innerHTML = `<div class="stats-header">ğŸŒ¡ï¸ å‹•æ…‹å¸‚å ´æ°›åœ</div><div class="stat-row">ç„¡ç›¸é—œæ¡ˆä¾‹</div>`;
        return;
    }

    const periods = [{ label: 'è¿‘1æœˆ', days: 30 }, { label: 'è¿‘3æœˆ', days: 90 }, { label: 'è¿‘6æœˆ', days: 180 }];
    let html = `<div class="stats-header">ğŸŒ¡ï¸ è¿‘æœŸå¸‚å ´ç«¶æ‹æ°›åœ (${guarantee})</div>`;

    periods.forEach(p => {
        const cutoff = new Date(); cutoff.setDate(cutoff.getDate() - p.days);
        // æ³¨æ„ï¼šé€™è£¡å‡è¨­ JSON è£¡æœ‰ 'é–‹æ¨™æ—¥æœŸ' æ¬„ä½ï¼Œè‹¥æ²’æœ‰å¯èƒ½éœ€èª¿æ•´
        const cases = similarCases.filter(item => {
             const dStr = item['é–‹æ¨™æ—¥æœŸ'] || item['ç«¶æ‹æˆªæ­¢æ—¥']; 
             return dStr && new Date(dStr) >= cutoff; 
        });

        if (cases.length > 0) {
            const avgMult = (cases.reduce((s, i) => s + safeFloat(i['æŠ•æ¨™å€æ•¸']), 0) / cases.length).toFixed(2);
            const avgPrem = (cases.reduce((s, i) => s + (safeFloat(i['å¹³å‡æº¢åƒ¹']) || safeFloat(i['æœ€ä½æº¢åƒ¹'])), 0) / cases.length).toFixed(2);
            // å–®ä½ä¿®æ­£
            let finalPrem = parseFloat(avgPrem);
            if(finalPrem < 2) finalPrem *= 100;
            
            const top3 = cases.sort((a, b) => safeFloat(b['æŠ•æ¨™å€æ•¸']) - safeFloat(a['æŠ•æ¨™å€æ•¸'])).slice(0, 3);
            const top3Str = top3.map(c => `${c['CBåç¨±'] || c['åç¨±'] || 'æ¨™çš„'}(${safeFloat(c['æŠ•æ¨™å€æ•¸'])}å€)`).join(', ');

            html += `
            <div style="margin-bottom:10px; padding:10px; background:white; border-radius:6px; box-shadow:0 1px 3px rgba(0,0,0,0.1);">
            <div style="font-weight:bold; color:#333; margin-bottom:5px;">ğŸ“… ${p.label} (æ¨£æœ¬:${cases.length})</div>
            <div class="stat-row" style="justify-content:space-between;">
            <span>ğŸ”¥ å¹³å‡å€æ•¸:<span style="color:#f57c00">${avgMult}</span></span>
            <span>ğŸ’° å¹³å‡æº¢åƒ¹:<span style="color:#d32f2f">${finalPrem.toFixed(2)}%</span></span>
            </div>
            <div style="font-size:12px; color:#666; margin-top:5px;">ğŸ† ç†±é–€: ${top3Str}</div>
            </div>
            `;
        }
    });
    div.innerHTML = html;
    div.style.display = 'block';
}

function generateRexCommentary(result) {
    const prem = parseFloat(result.totalAvgPremium); 
    let comment = "", strategy = "";

    if (prem >= 15) {
        comment = "ğŸ”¥ **å¸‚å ´éç†±è­¦ç¤º**ï¼šç›®å‰è©•ä¼°æº¢åƒ¹ç‡æ¥µé«˜ï¼Œé¡¯ç¤ºå¸‚å ´å°è©²é¡Œææ¥µåº¦è¿½æ§ã€‚éœ€æ³¨æ„ç†è«–åƒ¹æ ¼æ˜¯å¦å·²åœ¨é«˜æª”ã€‚";
        strategy = "å»ºè­°æ¡**ä¿å®ˆç­–ç•¥**ï¼Œæˆ–åƒ…ä»¥å°é‡è³‡é‡‘åƒèˆ‡ï¼Œé¿å…è¿½é«˜é¢¨éšªã€‚";
    } else if (prem >= 8) {
        comment = "ğŸ“ˆ **å¤šé ­è¶¨å‹¢æ˜ç¢º**ï¼šç¶œåˆæº¢åƒ¹ç‡é¡¯ç¤ºå¸‚å ´æƒ…ç·’æ¨‚è§€ï¼Œç”¢æ¥­èˆ‡ç™¼è¡Œæ¢ä»¶å‡å…·å¸å¼•åŠ›ã€‚";
        strategy = "å¯æ¡**ç©æ¥µç­–ç•¥**ï¼Œä½†éœ€ç•™æ„è½‰æ›åƒ¹æ˜¯å¦å…·å‚™æ”»æ“Šæ€§ã€‚";
    } else if (prem >= 3) {
        comment = "âš–ï¸ **å€é–“åˆç†éœ‡ç›ª**ï¼šç›®å‰çš„æº¢åƒ¹ç‡è™•æ–¼æ­·å²åˆç†å€é–“ï¼Œå¸‚å ´çœ‹æ³•ä¸­æ€§åå¤šã€‚";
        strategy = "å»ºè­°æ¡**å¹³è¡¡ç­–ç•¥**ï¼Œä»¥ç†è«–å¾—æ¨™åƒ¹ç‚ºåŸºæº–ï¼Œä¸Šä¸‹å¾®èª¿ 1~2 å…ƒé€²è¡ŒæŠ•æ¨™ã€‚";
    } else {
        comment = "ğŸ§Š **é˜²ç¦¦åƒ¹å€¼æµ®ç¾**ï¼šç›®å‰æº¢åƒ¹ç‡ä½æ–¼å¹³å‡æ°´æº–ï¼Œå¯èƒ½æ˜¯å¸‚å ´å¿½ç•¥çš„å†·é–€å„ªè³ªè‚¡ï¼Œæˆ–ç†è«–åƒ¹å·²åä½ã€‚";
        strategy = "å…·å‚™**é«˜å®‰å…¨é‚Šéš›**ï¼Œé©åˆé•·æœŸæŒæœ‰æˆ–å°‹æ±‚å¥—åˆ©æ©Ÿæœƒï¼Œå»ºè­°åœ¨æ­¤å€é–“ä½ˆå±€ã€‚";
    }

    return `
    <div class="rex-analysis" style="background:#fff3e0; padding:20px; border-radius:10px; margin-top:20px; border:2px solid #ffcc80;">
    <div class="rex-title" style="color:#e65100; font-weight:bold; font-size:18px; margin-bottom:10px;">ğŸ§¢ Rexå¤§å” æ™ºå›Šæˆ°ç•¥åˆ†æ</div>
    <div class="rex-content"><p>${comment}</p><p style="margin-top:10px;"><strong>ğŸ’¡ æ“ä½œå»ºè­°ï¼š</strong>${strategy}</p><p style="margin-top:10px; font-size:13px; color:#795548;">(æœ¬åˆ†æåŸºæ–¼æ­·å²å¤§æ•¸æ“šé‹ç®—ï¼Œåƒ…ä¾›åƒè€ƒï¼ŒæŠ•è³‡è«‹è‡ªè² ç›ˆè™§)</p></div>
    </div>
    `;
}

function calculateEvaluation(data) {
    const theoPrice = (data.stockPrice / data.conversionPrice) * 100;
    
    // å®šç¾©ç¶­åº¦è¨ˆç®— Helper
    const calcDim = (cat, val, label=null) => {
        let stats = getStatsSmart(cat, val);
        return {
            ...stats,
            coefficient: getWeightCoefficient(cat, label||val),
            range: label || stats.label || val
        };
    };

    const dimensions = {};
    dimensions.industry = { ...calcDim('ç”¢æ¥­', data.industry), weight: 0.25 };
    
    const brokerName = getBrokerName(data.cbName);
    dimensions.broker = brokerName ? { ...calcDim('ç™¼è¡Œåˆ¸å•†', brokerName), weight: 0.13 } : { low: 0, avg: 0, weight: 0.13, coefficient: 1.0, range: 'N/A' };
    
    // ä½¿ç”¨åˆ†é¡å¾Œçš„ Key ä¾†ç²å–ä¿‚æ•¸ (é€™æ˜¯é—œéµä¿®æ­£)
    const capKey = classifyCapital(data.capital);
    dimensions.capital = { ...calcDim('è‚¡æœ¬', data.capital, capKey), weight: 0.12 }; // æ³¨æ„é€™è£¡å‚³å›æ­£ç¢º Key
    
    const sizeKey = classifySize(data.issueSize);
    dimensions.size = { ...calcDim('ç™¼è¡Œè¦æ¨¡', data.issueSize, sizeKey), weight: 0.10 };
    
    let ratingKey = data.rating;
    if (ratingKey !== 'BBB') {
        const v = parseInt(ratingKey);
        ratingKey = v <= 3 ? '2-3åˆ†' : v <= 5 ? '4-5åˆ†' : v <= 7 ? '6-7åˆ†' : '8-9åˆ†'; // è‹¥éœ€è¦æ˜ å°„
    }
    dimensions.rating = { ...calcDim('ä¿¡è©•', data.rating), weight: 0.15 };
    
    dimensions.guarantee = { ...calcDim('æ“”ä¿', data.guarantee), weight: 0.12 };
    
    dimensions.years = { ...calcDim('å¹´æœŸ', data.years), weight: 0.08 };
    
    const convKey = classifyConversionPrice(data.conversionPrice);
    dimensions.conversion = { ...calcDim('è½‰æ›åƒ¹', data.conversionPrice, convKey), weight: 0.05 };
    
    // è¨ˆç®—åŠ æ¬Š
    const objectiveRatio = (100 - (data.subjectiveWeight || 0)) / 100;
    let weightedHistoricalLow = 0;
    let weightedHistoricalAvg = 0;
    
    for (const [key, dim] of Object.entries(dimensions)) {
        const coef = dim.coefficient || 1.0;
        const contributionLow = dim.low * dim.weight * coef * objectiveRatio;
        const contributionAvg = dim.avg * dim.weight * coef * objectiveRatio;
        
        weightedHistoricalLow += contributionLow;
        weightedHistoricalAvg += contributionAvg;
        
        dim.weightedLow = contributionLow;
        dim.weightedAvg = contributionAvg;
        dim.coefficient = coef;
    }
    
    const subjectiveRatio = (data.subjectiveWeight || 0) / 100;
    const weightedSubjectiveLow = (data.subjectiveLowPremium || 0) * subjectiveRatio;
    const weightedSubjectiveAvg = (data.subjectiveAvgPremium || 0) * subjectiveRatio;
    
    const totalLowPremium = weightedHistoricalLow + weightedSubjectiveLow;
    const totalAvgPremium = weightedHistoricalAvg + weightedSubjectiveAvg;
    const gap = totalAvgPremium - totalLowPremium;
    
    const bidPrices = {
        conservative: (theoPrice * (1 + totalLowPremium / 100)).toFixed(2),
        balanced: (theoPrice * (1 + totalAvgPremium / 100)).toFixed(2),
        aggressive: (theoPrice * (1 + (totalAvgPremium + gap) / 100)).toFixed(2),
        ultimate: (theoPrice * (1 + (totalAvgPremium + 2 * gap) / 100)).toFixed(2)
    };
    
    return {
        cbName: data.cbName,
        theoreticalPrice: theoPrice.toFixed(2),
        dimensions: dimensions,
        weightedHistoricalLow: weightedHistoricalLow.toFixed(2),
        weightedHistoricalAvg: weightedHistoricalAvg.toFixed(2),
        weightedSubjectiveLow: weightedSubjectiveLow.toFixed(2),
        weightedSubjectiveAvg: weightedSubjectiveAvg.toFixed(2),
        totalLowPremium: totalLowPremium.toFixed(2),
        totalAvgPremium: totalAvgPremium.toFixed(2),
        gap: gap.toFixed(2),
        bidPrices: bidPrices,
        inputData: data
    };
}

function displayResult(result) {
    document.getElementById('welcomeMsg').style.display = 'none';
    const resultDiv = document.getElementById('evaluationResult');
    resultDiv.className = 'evaluation-result active';
    
    const generateTableRows = () => {
        const dimNames = { industry: 'ç”¢æ¥­åˆ†é¡', broker: 'ç™¼è¡Œåˆ¸å•†', capital: 'è‚¡æœ¬å¤§å°', size: 'ç™¼è¡Œè¦æ¨¡', rating: 'ä¿¡ç”¨è©•ç­‰', guarantee: 'æ“”ä¿æƒ…æ³', years: 'ç™¼è¡Œå¹´æœŸ', conversion: 'è½‰æ›åƒ¹æ ¼' };
        let rows = '';
        for (const [key, name] of Object.entries(dimNames)) {
            const dim = result.dimensions[key];
            const fmt = (v) => safeFloat(v).toFixed(2);
            rows += `<tr><td>${name}</td><td>${dim.range}</td><td>${fmt(dim.low)}%</td><td>${fmt(dim.avg)}%</td><td>${(dim.weight * 100).toFixed(0)}%</td><td>${dim.coefficient.toFixed(3)}</td><td>${fmt(dim.weightedLow)}</td><td>${fmt(dim.weightedAvg)}</td></tr>`;
        }
        return rows;
    };
    
    const subjectiveRow = (result.inputData.subjectiveWeight || 0) > 0 ? `<tr style="background-color: #fff9e6;"><td><strong>ä¸»è§€æ¬Šé‡</strong></td><td>ä½¿ç”¨è€…è¼¸å…¥</td><td>${(result.inputData.subjectiveLowPremium||0).toFixed(2)}%</td><td>${(result.inputData.subjectiveAvgPremium||0).toFixed(2)}%</td><td>${result.inputData.subjectiveWeight}%</td><td>1.000</td><td style="color:#ff9800; font-weight:bold;">${result.weightedSubjectiveLow}</td><td style="color:#ff9800; font-weight:bold;">${result.weightedSubjectiveAvg}</td></tr>` : '';
    
    const tableHtml = `<table class="data-table"><thead><tr><th>ç¶­åº¦</th><th>æ¢ä»¶å€é–“</th><th>æ­·å²æœ€ä½æº¢åƒ¹</th><th>æ­·å²å¹³å‡æº¢åƒ¹</th><th>æ¬Šé‡</th><th>æ¬Šé‡ä¿‚æ•¸</th><th>æœ€ä½æº¢åƒ¹åŠ æ¬Š</th><th>å¹³å‡æº¢åƒ¹åŠ æ¬Š</th></tr></thead><tbody>${generateTableRows()}${subjectiveRow}<tr style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;"><td colspan="6" style="text-align: right; padding-right: 20px; font-weight: bold;">ç¸½è¨ˆ</td><td style="font-size: 18px; font-weight: bold;">${result.totalLowPremium}%</td><td style="font-size: 18px; font-weight: bold;">${result.totalAvgPremium}%</td></tr></tbody></table>`;
    
    resultDiv.innerHTML = `
    <div class="result-header"><h2>${result.cbName}</h2><div class="subtitle">AI æ™ºèƒ½è©•ä¼°çµæœ (V3.30 å„ªåŒ–ç‰ˆ)</div></div>
    <div class="detail-section"><h3>ğŸ“Š ç†è«–åƒ¹æ ¼</h3><div style="text-align:center; padding:20px; background:#f8f9fa; border-radius:10px;"><div style="font-size:48px; font-weight:bold; color:#667eea;">${result.theoreticalPrice} å…ƒ</div></div></div>
    <div class="detail-section"><h3>ğŸ” åˆ†æè©³æƒ…</h3>${tableHtml}</div>
    ${generateRexCommentary(result)}
    <div class="detail-section"><h3>ğŸ’¡ æŠ•æ¨™å»ºè­°</h3><div class="price-grid">
    <div class="strategy-card conservative"><h4>ğŸ›¡ï¸ ä¿å®ˆ</h4><div class="price">${result.bidPrices.conservative}</div></div>
    <div class="strategy-card balanced"><h4>âš–ï¸ å¹³è¡¡</h4><div class="price">${result.bidPrices.balanced}</div></div>
    <div class="strategy-card aggressive"><h4>ğŸš€ ç©æ¥µ</h4><div class="price">${result.bidPrices.aggressive}</div></div>
    <div class="strategy-card ultimate"><h4>ğŸ”¥ æ¥µè‡´</h4><div class="price">${result.bidPrices.ultimate}</div></div>
    </div></div>
    <div style="text-align:center; margin-top:30px;"><button onclick="location.reload()" style="padding:15px 40px; background:#667eea; color:white; border:none; border-radius:10px; cursor:pointer; font-weight:bold;">ğŸ”„ é‡æ–°è©•ä¼°</button></div>
    `;
    
    resultDiv.scrollIntoView({ behavior: 'smooth' });
}

document.getElementById('evaluationForm').addEventListener('submit', function(e) {
    e.preventDefault();
    const formData = {
        cbName: document.getElementById('cbName').value,
        industry: document.getElementById('industry').value,
        issueSize: parseFloat(document.getElementById('issueSize').value),
        years: parseInt(document.getElementById('years').value),
        guarantee: document.getElementById('guarantee').value,
        rating: document.getElementById('rating').value,
        capital: parseFloat(document.getElementById('capital').value),
        stockPrice: parseFloat(document.getElementById('stockPrice').value),
        conversionPrice: parseFloat(document.getElementById('conversionPrice').value),
        subjectiveWeight: parseFloat(document.getElementById('subjectiveWeight').value) || 0,
        subjectiveLowPremium: parseFloat(document.getElementById('subjectiveLowPremium').value) || 0,
        subjectiveAvgPremium: parseFloat(document.getElementById('subjectiveAvgPremium').value) || 0
    };
    displayResult(calculateEvaluation(formData));
});

window.addEventListener('DOMContentLoaded', loadStatistics);
</script>
